<html>

<head>
	<meta charset="UTF-8">
	<title>Pix2P5</title>
	<style>
        body {
            font-size: 18px;
        }

        #container {
            width: 512px;
            position: absolute;
            left: 0px;
            top: 0px;
        }

        .ioblock {
            width: 256px;
            height: 256px;
            position: absolute;
            border: 1px solid black;
            top: 0px;
        }

        #input {
            left: 0px;
        }

        #output {   
            left: 256px;
        }

        .btn {
            position: absolute;
            top: 265px;
        }

        #clearBtn {
            left: 0px;
        }

        #transferBtn {
            left: 60px;
        }

        #status {
            position: absolute;
            left: 0px;
            top: 294px;
            border: 1px solid black;
            width: 512px;
            height: 1.5em;
        }
    </style>
    <script src="./js/libraries/p5.min.js"></script>
    <script src="./js/libraries/ml5.min.js"></script>
    <script src="./js/libraries/opencv.js"></script>
    <script src="./js/libraries/p5.cv.min.js"></script> 
</head>

<body>
	<div id="container">
		<div class="ioblock" id="input"></div>
        <div class="ioblock" id="output"></div>
		<button class="btn" id="clearBtn">Clear</button><br>
		<button class="btn" id="transferBtn">Transfer</button>
        <div id="status"></div>
	</div>

    <script>
        "use strict";

        // Copyright (c) 2019 ml5
        //
        // This software is released under the MIT License.
        // https://opensource.org/licenses/MIT

        /* ===
        ml5 Example
        Pix2pix Edges2Pikachu example with p5.js using callback functions
        This uses a pre-trained model on Pikachu images
        For more models see: https://github.com/ml5js/ml5-data-and-training/tree/master/models/pix2pix
        === */

        // The pre-trained Edges2Pikachu model is trained on 256x256 images
        // So the input images can only be 256x256 or 512x512, or multiple of 256
        const SIZE = 256;
        let inputImg, inputCanvas, outputContainer, canvasElement, statusMsg, clearBtn, transferBtn;
        let pix2pix1, pix2pix2;
        let model1Ready = false;
        let model2Ready = false;
        let isTransfering = false;

        let video, cv1, mat1, contourFinder;

        function setup() {
            // Create a canvas
            inputCanvas = createCanvas(SIZE, SIZE);
            inputCanvas.parent("input");

            video = createCapture(VIDEO);
            video.size(SIZE, SIZE);
            video.hide();

            // Display initial input image
            inputImg = loadImage("./images/input.png", drawImage);

            // Selcect output div container
            outputContainer = select("#output");
            statusMsg = select("#status");
            statusMsg.html("Model loading...");

            // Select "transfer" button html element
            transferBtn = select("#transferBtn");

            // Select "clear" button html element
            clearBtn = select("#clearBtn");
            // Attach a mousePressed event to the "clear" button
            clearBtn.mousePressed(function() {
                clearCanvas();
            });

            // Set stroke to black
            stroke(0);
            pixelDensity(1);

            // Create a pix2pix method with a pre-trained model
            pix2pix1 = ml5.pix2pix("./models/d76_mix.pict", function() {
                console.log("Model 1/2 loaded!");
                statusMsg.html("Model 1/2 loaded!");
                model1Ready = true;
            });
            pix2pix2 = ml5.pix2pix("./models/nick_draw.pict", function() {
                console.log("Model 2/2 loaded!");
                statusMsg.html("Model 2/2 loaded!");
                model2Ready = true;

                transferBtn.mousePressed(function() {
                    transfer();
                });
            });

            p5.cv.onComplete = function() {
                console.log("Begin initializing CV");

                cv1 = p5.cv.getCvVideoCapture(video);
                mat1 = p5.cv.getRGBAMat(SIZE, SIZE);
                contourFinder = new ContourFinder();
                contourFinder.setMinArea(10).value();
                contourFinder.setMaxArea(200).value();
                contourFinder.setThreshold(127).value();
                contourFinder.setFindHoles(false);
                contourFinder.setTargetColor(color(255), p5.cv.TrackingColorMode.TRACK_COLOR_HSV);
            };
        }

        // Draw on the canvas when mouse is pressed
        function draw() {
            //cvLoaded();
            modelsLoaded();

            image(video, 0, 0, 256, 256);
            transfer();
            //filter(THRESHOLD, 0.3);
        }

        // Whenever mouse is released, transfer the current image if the model is loaded and it"s not in the process of another transformation
        function mouseReleased() {
            //if (modelReady && !isTransfering) {
                //transfer()
            //}
        }

        function cvLoaded() {
            if (p5.cv.isReady) {
                // read from CV Capture into myMat
                cv1.read(mat1);

                // search for contours in the latest frame
                contourFinder.findContours(mat1);
                console.log("Found " + contourFinder.size() + " contours");
                
                // display Mat
                p5.cv.drawMat(mat1, 0, 0);
                // draw contours
                contourFinder.draw();
            }
        }

        function modelsLoaded() {
            if (model1Ready && model2Ready) {
                transfer();
            }
        }

        // Draw the input image to the canvas
        function drawImage() {
            image(video, 0, 0);
        }

        // Clear the canvas
        function clearCanvas() {
            background(255);
        }

        function transfer() {
            // Set isTransfering to true
            isTransfering = true;

            // Update status message
            statusMsg.html("Applying Style Transfer...");

            // Select canvas DOM element
            canvasElement = select("canvas").elt;

            // Apply pix2pix transformation
            pix2pix1.transfer(canvasElement, function(err, result1) {
                if (err) {
                    console.log(err);
                }

                if (result1 && result1.src) {
                    // Set isTransfering back to false
                    //isTransfering = false;
                    // Clear output container
                    //outputContainer.html("");
                    // Create an image based result
                    //createImg(result.src).parent("output");
                    // Show "Done!" message
                    statusMsg.html("1/2 Done!");

                    pix2pix2.transfer(result1.src, function(err, result2) {
                        if (err) {
                            console.log(err);
                        }

                        if (result2 && result2.src) {
                            // Set isTransfering back to false
                            isTransfering = false;
                            // Clear output container
                            outputContainer.html("");
                            // Create an image based result
                            createImg(result2.src).parent("output");
                            // Show "Done!" message
                            statusMsg.html("2/2 Done!");
                        }
                    });
                }
            });
        }
    </script>
</body>

</html>